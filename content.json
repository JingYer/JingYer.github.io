{"meta":{"title":"Xspace","subtitle":null,"description":null,"author":"Xin Guo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"'new'","date":"2018-11-27T04:11:12.000Z","updated":"2018-11-27T04:11:12.069Z","comments":true,"path":"new/index.html","permalink":"http://yoursite.com/new/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack+vue搭建todolist应用","slug":"webpack-vue搭建todolist应用","date":"2019-03-12T08:45:49.000Z","updated":"2019-03-12T08:47:36.597Z","comments":true,"path":"2019/03/12/webpack-vue搭建todolist应用/","link":"","permalink":"http://yoursite.com/2019/03/12/webpack-vue搭建todolist应用/","excerpt":"","text":"webpack+vue 打造todolist应用熟悉使用webpack搭建基于vue框架的web应用，包括webpack配置，web-dev-server，.vue文件，以及vue父子组件间通信。将介绍整体搭建流程以及出现问题的解决方法，总结其中的一些知识点。 所用工具、框架等版本一览12345678910111213141516171819202122232425262728293031&#123; \"name\": \"vue-ssr-tech-2\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --mode production\", \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"autoprefixer\": \"^9.4.10\", \"cross-env\": \"^5.2.0\", \"css-loader\": \"^2.1.0\", \"file-loader\": \"^3.0.1\", \"html-webpack-plugin\": \"^3.2.0\", \"postcss-loader\": \"^3.0.0\", \"style-loader\": \"^0.23.1\", \"stylus\": \"^0.54.5\", \"stylus-loader\": \"^3.0.2\", \"url-loader\": \"^1.1.2\", \"vue\": \"^2.6.8\", \"vue-loader\": \"^15.7.0\", \"vue-template-compiler\": \"^2.6.8\", \"webpack\": \"^4.29.6\", \"webpack-cli\": \"^3.2.3\", \"webpack-dev-server\": \"^3.2.1\" &#125;&#125; webpack相关知识 “本质上，webpack是一个现代JavaScript应用程序的静态模块打包器（module bundler）。当webpack处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle” 四个核心概念 入口（entry）：指示webpack应该使用哪个模块，来作为构建其内部依赖图的开始。 输出（output）：告诉webpack在哪里输出它所创建的bundles，以及如何命名这些文件。 loader：让webpack能够去处理那些非JavaScript文件。 插件（plugins）：loader用来转换某些类型的模块，插件则可以执行范围更广的任务，从打包优化和压缩，到重新定义环境中变量。 12345678910111213141516171819202122232425262728293031323334353637const path = require('path');//引入node.js path模块const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装，详细见下文const webpack = require('webpack'); // 用于访问内置插件module.exports = &#123; entry: path.join(__dirname,'./src/index.js'),//官网上给出的是entry:'./src/index.js'，详细见下文 output: &#123; path: path.join(__dirname,'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ //以下是几种写法 &#123;test:/\\.vue$/, loader:'vue-loader'&#125;, &#123;test:/\\.vue$/, use:'vue-loader'&#125;, &#123;test:/\\.css$/, use:['css-loader','style-loader'&#125;, &#123; test: /\\.styl/, use: [ 'style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; sourceMap: true &#125; &#125;, 'stylus-loader' ] &#125; &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: './dist/index.html'&#125;) ]&#125;;module.exports = config; HtmlWebpackPlugin插件。这个插件基本作用就是生成html文件（暂时理解至此），实例化该插件时可以像上述代码不配置任何参数，那么它会默认将所有的js和css样式都插入到文件指定位置。（具体[HtmlWebpackPlugin][https://segmentfault.com/a/1190000013883242?utm_source=tag-newest]） node.js path模块。path.join([path1] [, path2] [, path3]… )，用于连接路径，主要用途在于可以正确使用当前系统的路径分隔符。path.resolve([from …], to)，用于将to参数解析为绝对路径，比如path.resolve(‘/foo/bar’, ‘./baz’);得到’/foo/bar/baz’，path.resolve(‘/foo/bar’, ‘/tmp/file/‘);得到’/tmp/file’。 dirname是指当前文件所在目录的绝对路径。path.join(dirname,’./src/index.js’)写成path.resolve一样。 Start建立文件夹，命名为VUE-SSR-TECH-2，vscode终端切换至该文件夹 1npm init 不断Enter后，文件夹下出现package.json。 1npm i webpack vue vue-loader 根据提示，继续安装缺少的模块。此版本下 1npm i css-loader 在总目录下新建并编写webpack.config.js，package.json。详见代码。 接下来说webpack-dev-server。如果不使用webpack-dev-server，每次运行代码都需要npm run build，使用之后，可以在本地部署，无需每次都在终端里运行命令，开启webpack-dev-server热加载后，还可以实现热更新。(cross-env：跨平台设置和使用环境变量,postcss-loader：自动添加浏览器前缀)。 在使用vue、react等框架的时候，一定要用一个插件：根据环境不同打包代码 12345new webpack.DefinePlugin(&#123; &apos;process.env&apos;: &#123; NODE_ENV: isDev ? &apos;&quot;development&quot;&apos; : &apos;&quot;production&quot;&apos; &#125;&#125;) 1npm i webpack-dev-server 根据报错提示，安装插件。 1npm i cross-env webpack-cli vue-template-compiler file-loader stylus-loader stylus style-loader postcss-loader autoprefixer 报了几个错误：1、版本问题，根据提示安装相应的版本； 2、设置devserver的host问题，本机ip改变，直接设置了0.0.0.0报错。 3、Error:No PostCSS Config found。该错误原因在于不同浏览器前缀不同，需要进行设置，使用postcss-loader插件。具体方法是建立一个postcss.config.js文件，安装autoprefixer插件。 4、CssSyntaxError Unknown word。这种错误是之前没遇到过的，后来发现原因在于：在webpack.config.js文件中，module的rules里，对于.css文件的匹配，要先写’style-loader’，再写’css-loader’，之前写反了就会报错。 5、同样的，匹配.stylus，’stylus-loader’要写在几个插件最后。 6、打包成功后，发现dist文件夹里并没有生成index.html，bundle.js等文件，查询之后发现好像是webpack版本问题，暂未找到解决方法。使用课上所讲的npm run build方法可以生成，但是用npm run dev无法生成。 接下来写业务，vue组件。 vuevue的render方法：是对template内容一层层进行遍历，并creatElement，最终得到整个组建的节点树。$mount(node)将上述节点树挂载在node节点上。 vue将整个页面看作一个个组件构成。todolist应用页面可看作以下组件构成： 数据值一般集中在顶层组件中。 父子组件传值：父组件值传递给子组件，首先在父组件中使用子组件时，要对子组件的属性绑定该值；然后子组件使用props进行接收，使用时与自己data返回的值使用方法相同，模板内直接使用，方法中使用this.属性名。子组件值传递给父组件，首先在子组件中用this.$emit(eventName,[…args])，eventName为父组件中的事件名，其后接要传递的参数；然后父组件要使用子组件传值的地方，定义一个事件@eventName=name，name为父组件中接收子组件值并处理的函数。 @事件名=“方法”，如果无参数，可以直接写方法名，有参数，要写成方法名（参数名） 用到的一些js方法：String.trim()，删除字符串的头尾空格，不改变原始字符串 Array.unshift(item1,itme2,…,itemx)，向数组开头添加一个或多个元素，返回新的长度，此方法将改变原数组，如果一次添加多个，如 123let a = [1,2,3];a.unshift(4,5);console.log(a);//4,5,1,2,3 Array.push(item1,item2,…,itemx)，向数组末尾添加一个或多个元素，返回新的长度，此方法将改变原数组。 Array.splice(index,howmany,item1,…,itemx) item可选，添加或删除数组中的元素，将会改变原数组。 Array.findIndex(func(currentValue,index,arr),thisValue),thisValue可选,index可选,arr可选。返回符合测试条件的第一个元素位置，不改变原始数组。不会对空数组检测，找不到的返回-1。 Array.filter(func(currentValue,index,arr),thisValue),thisValue可选,index可选,arr可选。返回符合测试条件的一个新数组，不改变原始数组。不会对空数组进行检测。找不到返回空数组。","categories":[],"tags":[]},{"title":"hexo-tutorial","slug":"hexo","date":"2019-03-04T11:54:54.000Z","updated":"2019-03-05T07:06:18.417Z","comments":true,"path":"2019/03/04/hexo/","link":"","permalink":"http://yoursite.com/2019/03/04/hexo/","excerpt":"","text":"本篇主要用来讲解如何使用hexo和GitHub搭建个人博客。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-27T04:06:02.218Z","updated":"2018-11-27T04:06:02.218Z","comments":true,"path":"2018/11/27/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}